package commands

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/cursor-cold-start/cursor-cold-start/internal/template"
	"github.com/cursor-cold-start/cursor-cold-start/pkg/utils"
)

const generatedFilesListName = ".coldstart-generated"

// generatePackRules 生成功能包规则，返回生成的文件名列表
// 同时返回所有 pack 的文件名映射（包括禁用的），用于清理
func generatePackRules(rulesDir string, packs map[string]interface{}, values map[string]interface{}, processor *template.Processor, templateDir string) ([]string, map[string]string) {
	var generatedFiles []string
	packFileMap := make(map[string]string) // packID -> 文件名（用于清理）
	packsDir := filepath.Join(templateDir, "templates", "packs")

	// 遍历所有功能包
	packEntries, _ := os.ReadDir(packsDir)
	for _, packEntry := range packEntries {
		if !packEntry.IsDir() {
			continue
		}

		packID := packEntry.Name()
		packConfig, ok := packs[packID].(map[string]interface{})

		// 读取 pack.config.json 获取优先级（即使 pack 未启用或不存在，也需要知道文件名）
		packConfigFile := filepath.Join(packsDir, packID, "pack.config.json")
		packMeta, err := readJSONFile(packConfigFile)
		if err != nil {
			continue
		}

		priority := int(getFloatValue(packMeta, "priority"))
		if priority == 0 {
			priority = 40 // 默认优先级
		}

		// 获取 pack 可能生成的文件名（用于清理）
		rulesPath := filepath.Join(packsDir, packID, "rules")
		var ruleEntries []os.DirEntry
		if utils.DirExists(rulesPath) {
			ruleEntries, _ = os.ReadDir(rulesPath)
			// 记录 pack 对应的文件名（用于清理）
			for _, ruleEntry := range ruleEntries {
				if ruleEntry.IsDir() || !strings.HasSuffix(ruleEntry.Name(), ".template") {
					continue
				}
				baseName := strings.TrimSuffix(ruleEntry.Name(), ".template")
				outputFileName := fmt.Sprintf("%d-%s", priority, baseName)
				packFileMap[packID] = outputFileName
			}
		}

		// 如果 pack 不在配置中，跳过生成（但已记录文件名用于清理）
		if !ok {
			continue
		}

		// 检查是否启用
		if !getBoolValue(packConfig, "enabled") {
			continue
		}

		// 检查依赖
		dependencies := getStringSliceFromInterface(packMeta["dependencies"])
		missingDeps := []string{}
		for _, dep := range dependencies {
			depConfig, ok := packs[dep].(map[string]interface{})
			if !ok || !getBoolValue(depConfig, "enabled") {
				missingDeps = append(missingDeps, dep)
			}
		}
		if len(missingDeps) > 0 {
			fmt.Printf("  ⚠️  %s (跳过: 缺少依赖 %v)\n", packID, missingDeps)
			continue
		}

		// 合并 pack 特定配置到 values
		packValues := make(map[string]interface{})
		for k, v := range values {
			packValues[k] = v
		}

		// 添加 pack 配置（使用智能字段映射）
		if packCfg, ok := packConfig["config"].(map[string]interface{}); ok {
			for k, v := range packCfg {
				// 字段名映射表
				fieldMapping := map[string]string{
					"serviceClass": "LOGGER_SERVICE_CLASS",
					"filePath":     "LOG_FILE_PATH",
					"sourceFile":   "VERSION_SOURCE_FILE",
					"packageName":  "PACKAGE_NAME",
					"moduleName":   "MODULE_NAME",
					"modulePath":   "MODULE_PATH",
				}

				if mappedKey, ok := fieldMapping[k]; ok {
					packValues[mappedKey] = v
				} else {
					// 默认转换为大写下划线格式
					packValues[toUpperSnakeCase(k)] = v
				}
			}
		}

		// 生成规则文件
		if len(ruleEntries) > 0 {
			for _, ruleEntry := range ruleEntries {
				if ruleEntry.IsDir() || !strings.HasSuffix(ruleEntry.Name(), ".template") {
					continue
				}

				templateFile := filepath.Join(rulesPath, ruleEntry.Name())
				baseName := strings.TrimSuffix(ruleEntry.Name(), ".template")
				outputFileName := fmt.Sprintf("%d-%s", priority, baseName)
				outputFile := filepath.Join(rulesDir, outputFileName)

				if err := processor.RenderTemplateToFile(templateFile, outputFile, packValues); err != nil {
					fmt.Printf("  ⚠️  %s (跳过: %v)\n", outputFileName, err)
					continue
				}
				fmt.Printf("  ✅ %s\n", outputFileName)
				generatedFiles = append(generatedFiles, outputFileName)
			}
		}
	}

	return generatedFiles, packFileMap
}

// loadGeneratedFilesList 加载之前生成的文件清单
func loadGeneratedFilesList(rulesDir string) map[string]bool {
	listFile := filepath.Join(rulesDir, generatedFilesListName)
	data, err := os.ReadFile(listFile)
	if err != nil {
		return nil
	}

	files := make(map[string]bool)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line != "" && !strings.HasPrefix(line, "#") {
			files[line] = true
		}
	}
	return files
}

// saveGeneratedFilesListToFile 保存生成的文件清单
func saveGeneratedFilesListToFile(rulesDir string, files map[string]bool) {
	listFile := filepath.Join(rulesDir, generatedFilesListName)

	var lines []string
	lines = append(lines, "# This file is auto-generated by coldstart")
	lines = append(lines, "# Do not edit manually")
	lines = append(lines, "")

	// 排序以保持稳定输出
	var sortedFiles []string
	for f := range files {
		sortedFiles = append(sortedFiles, f)
	}
	sort.Strings(sortedFiles)

	lines = append(lines, sortedFiles...)

	content := strings.Join(lines, "\n") + "\n"
	if err := os.WriteFile(listFile, []byte(content), 0644); err != nil {
		fmt.Printf("  ⚠️  无法保存文件清单: %v\n", err)
	}
}

