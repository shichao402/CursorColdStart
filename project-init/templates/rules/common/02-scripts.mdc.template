---
alwaysApply: true
---
# 脚本规则 - 最高优先级

## 核心约束（强制）

1. **所有调试操作必须使用项目中已有的脚本**，禁止手动执行命令
2. 如果脚本无法完成工作，**必须修改脚本**使其正常工作
3. AI必须主动执行脚本，不要求用户操作
4. **所有脚本必须支持跨平台**，必须提供 Windows、macOS 和 Linux 的入口脚本

## 脚本设计原则（指导性）

### 1. 模块化设计

- **原则：** 脚本应该尽量模块化，每个脚本负责单一职责
- **目标：** 提高脚本的可维护性和可复用性
- **实践：** 将复杂的操作拆分为多个独立的脚本模块

### 2. 单点可复用

- **原则：** 功能应该是单点可复用的，避免重复编写相同逻辑
- **示例：** 
  - 部署脚本应该**调用**构建脚本，而不是重复编写构建逻辑
  - 构建脚本应该**调用**清理脚本，而不是重复编写清理逻辑
  - 启动脚本应该**调用**部署脚本，而不是重复编写部署逻辑
- **目标：** 确保每个功能只在一个地方实现，便于维护和更新
- **实践：** 
  ```bash
  # ✅ 好的做法 - 部署脚本调用其他脚本
  ./scripts/build.sh
  ./scripts/deploy.sh
  ./scripts/start.sh
  
  # ❌ 不好的做法 - 在部署脚本中重复编写构建逻辑
  # 直接在 deploy.sh 中写 flutter build apk 等命令
  ```

### 3. 跨平台支持（强制）

- **原则：** 所有脚本必须支持跨平台，提供各平台的入口脚本
- **目标：** 确保脚本在 Windows、macOS 和 Linux 上都能正常工作
- **实现方式：**
  - **推荐：** 使用跨平台语言（如 Python）实现核心逻辑，各平台提供代理入口脚本
  - **备选：** 使用平台特定的脚本语言，但必须提供所有平台的版本

#### 平台代理入口脚本模式（推荐）

**核心实现：** 使用 Python 等跨平台语言实现核心逻辑
**入口脚本：** 各平台提供简单的代理脚本调用核心实现

**目录结构：**
```
scripts/
├── build.py              # 核心实现（Python，跨平台）
├── build.sh              # macOS/Linux 入口脚本
├── build.bat             # Windows 入口脚本
├── deploy.py             # 核心实现
├── deploy.sh             # macOS/Linux 入口脚本
└── deploy.bat            # Windows 入口脚本
```

**Windows 入口脚本示例（build.bat）：**
```batch
@echo off
REM 获取脚本所在目录
set SCRIPT_DIR=%~dp0
REM 使用虚拟环境的 Python 运行核心脚本
"%SCRIPT_DIR%..venv\Scripts\python.exe" "%SCRIPT_DIR%build.py" %*
```

**macOS/Linux 入口脚本示例（build.sh）：**
```bash
#!/bin/bash
# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# 使用虚拟环境的 Python 运行核心脚本
exec "$SCRIPT_DIR/../.venv/bin/python" "$SCRIPT_DIR/build.py" "$@"
```

**核心脚本示例（build.py）：**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
跨平台构建脚本
"""
import sys
from pathlib import Path

def main():
    # 跨平台路径处理
    script_dir = Path(__file__).parent.resolve()
    project_root = script_dir.parent
    
    # 跨平台命令执行
    # ... 构建逻辑 ...
    pass

if __name__ == '__main__':
    main()
```

#### 纯脚本语言模式（备选）

如果使用纯脚本语言，必须提供所有平台的版本：

**Windows 批处理脚本（build.bat）：**
```batch
@echo off
setlocal
set SCRIPT_DIR=%~dp0
cd /d "%SCRIPT_DIR%.."
REM Windows 特定的构建命令
flutter build apk
```

**macOS/Linux Shell 脚本（build.sh）：**
```bash
#!/bin/bash
set -e
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR/.."
# Unix 特定的构建命令
flutter build apk
```

#### 跨平台路径处理

无论使用哪种模式，都必须正确处理跨平台路径：

```python
# Python - 跨平台路径处理
from pathlib import Path
script_dir = Path(__file__).parent.resolve()
project_root = script_dir.parent
```

```bash
# Shell - Unix 路径处理
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
```

```batch
REM Batch - Windows 路径处理
set SCRIPT_DIR=%~dp0
```

## 部署脚本

{{ DEPLOY_SCRIPTS_DESCRIPTION }}

## 禁止行为

- ❌ 手动查找{{ BUILD_TOOL }}路径
- ❌ 手动执行{{ BUILD_TOOL }}命令（build、run、install等）
- ❌ 手动使用系统命令收集日志
- ❌ 手动访问日志文件路径
- ❌ 不使用预置脚本进行任何调试操作
- ❌ 要求用户手动执行命令
- ❌ 绕过脚本直接操作
- ❌ 脚本失败后不使用脚本，改为手动执行命令
- ❌ 要求用户手动修复脚本
- ❌ 跳过脚本直接操作
- ❌ 不修复脚本而使用临时方案
- ❌ **只提供单一平台的脚本**（必须支持 Windows、macOS、Linux）
- ❌ **使用平台特定的命令而不提供跨平台实现**
- ❌ **硬编码平台特定的路径或命令**

## 必须遵守

- ✅ 所有部署必须使用部署脚本
- ✅ 所有日志收集必须使用日志收集脚本
- ✅ 脚本出现问题必须立即修复
- ✅ 修复脚本是AI的责任，不得推给用户
- ✅ 修复后的脚本必须能够正常完成预期功能
- ✅ 修复脚本后必须验证脚本能够正常工作
- ✅ 保持脚本的健壮性和可维护性
- ✅ AI必须主动执行脚本，不要求用户操作
- ✅ **所有脚本必须提供跨平台支持**（Windows、macOS、Linux）
- ✅ **必须提供各平台的入口脚本**（.bat 用于 Windows，.sh 用于 macOS/Linux）
- ✅ **推荐使用跨平台语言（如 Python）实现核心逻辑**，各平台入口脚本调用核心实现

## 脚本维护规则（强制）

**如果预置脚本无法完成工作，必须修改脚本使其符合预期正常工作。**

### 脚本问题处理流程

1. **发现问题：** 当脚本执行失败或无法完成预期功能时
2. **分析问题：** 检查脚本错误信息，定位问题原因
3. **修复脚本：** 直接修改脚本文件，使其能够正常工作
4. **验证修复：** 重新执行脚本，确保问题已解决
5. **继续工作：** 使用修复后的脚本继续完成调试任务

